# 本当の意味でユニークな部分を見つけて埋めるソルバー

## 懸念点
- そんな場所は存在しない、もしくは本当に少ない場合意味をなさない
- パラレル的に候補が増えて、めちゃくちゃ時間かかるかも

## 方針
- パーツからトライ木を作成
- 葉以外の部分はユニークの候補から削除する
- サフィックスノード（？）を作成
- 入力文字列で木をたどっていく
- この時以下の操作を行う
	- 今の地点の候補はqueueに格納
	- 現在のノードが葉の時以下の操作をする
		- 初めての来訪の時
			- 来訪したことをノードに記入
			- 来訪したタイミングを記入
		- 2回目以降の時
			- 来訪した記録を抹消、もしくは無効にする
			- ルートにたどって行き、分岐の発生する手前までノードを無効化する。
	- それぞれの地点から移動
		- a-dの時は次の地点をqueueに登録
		- xの時は、全ての記号の場合を試す。
		- この時、移動先のノードが無効の時はサフィックス木を辿る(下に降っても無効になってるから)
			- 無効でない場所まで登った段階で、その場所にサフィックスノードを接続し直す。
		- 移動さきがすでにこの回でqueueに追加されていたら、追加せず、到達数を記入する

## 方針の解説
候補の増加とともに、計算量の増加が予測されるが、葉に二回以上（実質的に）到達した場合、そのルートの分岐の部分まで、無効にすることが可能なので、ノード数は減少して行き、計算量を減らすことが可能なのではないかと予測する。

これらが実時間内に実行可能なのかを検証する。

## 結論？
えー、５つのサンプルで試してみたところ、平均して１０秒ほどの実行時間となりました。

何度もいうようなのですが、これを実行すると、パーツにとって唯一あてはまれる場所があった場合、それがわかるというものでした。

結果、唯一とかになりそうなパターンは５個試して、一個しか出現しませんでした。

とても悲しいです。

まぁ要約すると、0.001%の確実な穴埋めを進めるのに10秒かかるということです。しかも、埋まらないことも...

まぁ裏を返すと、決まったパターンがわりかし多いということなので、推定の方の精度は上がりやすいかな、うん

まぁ、もしかしたら、今回のパターンが特殊で色々試してみると、意外と埋まるみたいな可能性を信じて、残しておきます。

はぁ...

# ユニークを見つける旅Part２
## ある文字列が当てはまるかどうかを探索する時
N文字目まで一致していた！って時に、そのN文字目までのパターン次はここにあるよ、みたいなのわかったら便利だなーって

んでそれを2^nの文字数単位でわかれば、計算量減らして、目的地にたどり着けるのでは？と思った。

問題はxの取り扱い方。

特に遷移先は実はこの文字は許可してません...みたいなのが発生しそう。

そこで、xはその段階では決められない文字として、何が入ってもいいことにして、実際の一致については文字列が出てきてから行う。

遷移先が短くなる問題は発生するが問題は起こりにくくなる。

遷移先を決められない事案が発生したので、別の案へそのまま移行


# ユニークを見つける旅Part3
これは画期的！

手順として以下のようになる。
- 任意の値nを定める。(nは１０あたりが現実的、本番なら12でも行けるかも！？)
- 文字列を先頭から順に５進数の数と見た時に、aーdは0-3でxとして変換する。
- 次に同じパターンが現れた時、その位置から前の出現位置にいけるように変数を保持する。
- これを最後まで行い、これにより、特定のn文字が出現するところへの一本道ができる。
- 次に、パーツを当てはめていくが、これも5進数に変換する。
- ただし、各数値がxとなった場合も考慮して、5進数を2^n個作成する。
- 2^n回だけ、一本道を移動して、その先々で、完全一致するかを検証する。
- 以上の方法により、比較回数を一気に減らせるため、0.5秒程度で全てのパーツを比較できる

なお、並列での処理も可能なので、やろうと思えば、かなり時間へ減らせると考えられる。



